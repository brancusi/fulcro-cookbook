[#dynamic-recursion]
==== Solving mutually recursive elements with lazy loading with hooks and dynamic components
:imagesdir: ./dynamic-recursion
ifdef::env-vscode[]
:imagesdir: .
endif::[]

How do we model our UI and get our data, when we have two mutually recursive elements? Here we want to display Recipes composed of LineItems with a quantity, unit of measure (uom), and either an ingredient or a sub-recipe: 

.The desired UI
image::./recipes-ui.svg["UI wireframes",35%,opts=inline]

.The data model in our SQL database
ifdef::env-github[image::data-model.png[Data model]]
ifndef::env-github[]
[plantuml,data-model,png]
.... 
@startuml
entity Recipe {
  id : string
  name : string
  line-items : [LineItem]
}
entity LineItem {
  id : string
  quantity : number
  uom : litre|piece|teaspoon|...
  ingredient : Ingredient
  sub-recipe : Recipe
}
Recipe "1" *- "+" LineItem
LineItem o- "0..1" Recipe
@enduml
....

Some cases are just too complex to solve with recursive queries. In this case we have a Recipe that has a list of "line items," each with a quantity and unit of measure (`uom`), where the item can be either a raw ingredient or another recipe. So the recursion here is across two elements: Recipe → line item → Recipe. Moreover, we only want to load the details of sub-recipes on demand.

===== Setting the scene

TODO: data model (graph/tree), ? side-by-side of data tree and rendering tree (comp. instances), how comp queries mimic data model shape
TODO How side-effect (load/mutation/progress/web socket push, etc.) populates some portion of that tree, via a remote or data merge with a query fragment.

This is what the data looks like:

* Recipe 1: "Pancakes"
** Line item 1: quantity 1, uom :litre
*** Ingredient: "Milk"
** Line item 2: quantity 2, uom :piece
*** Ingredient: "Egg"
** Line item 3: quantity 0.3, uom :litre
*** Recipe: "Home-made yoghurt"
**** Line item 1: quantity 1, uom :litre
***** Ingredient: "Milk"
...

===== Our options

TODO: How can we deal with this problem?

===== Insights

.Insights
****
If a static query doesn’t work for that, then the options are dynamic query, or breaking out of the model and using something like a use-component hook.
The former works in 95% of every case, the middle one works in a few cases, and the latter covers the rest.

You could ask, if I can just do everything with use-component, then why not just supply that, and drop the components and static queries altogether?

Because the static query mechanism offers a few advantages:

* Possibility to define a global initial data model locally, component by component, via its `:initial-state`, instead of doing it at some remote place or using component-local state
* Side-effects combined with rendering (i.e. what most of React hooks do) cause problems:
 ** Hot code reload doesn't work cleanly, since components aren't pure functions anymore
 ** Controlling the lifecycle of data becomes more difficult because it is tied to when things are mounted as opposed to compositional logic outside of rendering.
 ** Refactoring UI breaks things (e.g. a side effect A did accidentally gets coupled to B. Move A and B stops working).
* Easier to trace what is going on in the data model because it is simpler - each component gets its data only from its parent, and you can see what is the data tree going into the Root component
* The query itself becomes a useful source of information (which we leverage e.g. for Dynamic Routing)
****

===== All the rest...

This mutual recursion is difficult, if not impossible, to do with just queries.


TIP: We could still solve it with recursive queries, if we separate sub-recipes and the information about quantities. So a Recipe would have data such as `#:recipe{:ingredient-line-items [{:quantity 2, :uom :teaspoon :ingredient {:id ".." :name "Salt"}},...], :sub-recipes [#:recipe{:id "rec2", ...}] :sub-recipe-quantities {"rec2" {:quanity 0.1, :uom :litre}, ..}}` and query `[:recipe/ingredient-line-items (get-query IngredientLineItem) {:recipe/sub-recipes 1} :recipe/sub-recipe-quantities]`. It works but it is not elegant. Therefore we explore a different solution here, which enables us to do exactly what we want.

This is a perfect use case for dynamic components and hooks, namely `use-component`.

What we will do is to load a Recipe that has a RecipeLineItem that _refers_ to a Recipe (just the ID and name, avoiding the problematic recursive items). We then swap out the reference for a dynamically loaded entity when the user wants to see the details of the sub-recipe. We also use a union query for the RecipeLineItem's child, though it is not strictly necessary (it could simply query for both and always get just one of them).

There is a slight complication with the on-demand loading of the sub-recipe because the use-component hook is slightly tricky to use with something that hasn’t been loaded yet, since it needs some data to exist in the client DB. We will therefore initialize the `DynamicRecipe` component via `:initial-params` together with specifying `:initial-state` for the `Recipe` so that the hook can then make an “empty” but properly identified placeholder in the database to hook up to while the load runs. I.e. `use-component` with `:initial-params` generates a `{:recipe/id n}` map and normalizes it (which puts the ident in place for finding it as well). Then the load gets issued. When the details arrive you’ve got the full recipe.

.dynamic-recursion-cards
====
//include::https://raw.githubusercontent.com/fulcrologic/fulcro/c6c490b6e4a5461628bd940a5c6b067ee002775a/src/workspaces/com/fulcrologic/fulcro/cards/dynamic_recursion_cards.cljs[] 
[source,clojure]
----
include::./dynamic_recursion_cards.cljs[]
----
====